# 16高级数据类型

16和17章讨论额外的部分，允许应用使用Java语言访问SQL2003数据类型，例如二进制大对象和结构化类型。
本章还会描述RowId的使用，RowId被许多数据源支持。如果数据源不支持这2章讨论的高级数据类型，
那driver不要求实现这些方法和数据类型。

## 16.1 SQL类型的分类

最新版的ANSI/ISO的SQL标准通常参考SQL:2003, JDBC API包含一个SQL2003的数据类型模型，
包含那些Java语言交换数据时必不可少的数据类型和属性。

SQL2003执行这些数据类型：
* SQL92内置类型---熟悉的SQL列类型
    * CHAR
    * FLOAT
    * DATE
    * 等等
* SQL99内置类型---SQL99增加的
    * BOOLEAN 
    * BLOB --- 二进制大对象
    * CLOB --- 字符大对象
* 新增内置类型---SQL2003新增
    * XML --- XML对象
* 用户自定义类型
    * 结构化类型 --- 例如
        * CREATE TYPE PLANE_POINT AS (X FLOAT, Y FLOAT) NOT FINAL
    * DISTINCT 类型 --- 例如
        * CREATE TYPE MONEY AS NUMERIC(10,2) FINAL    
* 构造类型 --- 基于基础类型的新类型
    * REF(structured-type) --- 指向数据库结构化类型实例的指针
    * base-type ARRAY[n] --- n个基础类型的数组
* Locator --- 指向数据的逻辑指针实体。
    * LOCATOR(structured-type)
    * LOCATOR(array)
    * LOCATOR(blob)
    * LOCATOR(clob)
* 管理外部数据的类型
    * Datalink --- 外部数据的一个引用，数据源管理外部数据的引用有以下好处
        * 参照完整性：外部数据不能被文件系统API直接删除和重名名
        * 访问控制：访问可以被配置
        * 备份和恢复
        * 事务一致性

## 16.2 高级数据类型映射

JDBC API提供了默认映射，除了DISTINCT和Datalink。

* BLOB --- Blob接口
* CLOB --- Clob接口
* NCLOB --- NClob接口
* ARRAY --- Array接口
* XML --- SQLXML接口
* 结构化类型 --- Struct接口
* REF(structured-type) --- Ref接口
* ROWID --- RowId接口

其他高级类型的默认映射为：

* DISTINCT --- 基础类型已经映射，例如，基于SQL NUMERIC类型的DISTINCT值映射为java.math.BigDecimal
* DATALINK --- java.net.URL对象

## 16.3 Blob、Clob和NClob对象

### 16.3.1 Blob、Clob、NClob实现

要么是一个locator，要么是客户端的完全物化对象结果。

默认， JDBC driver应该实现Blob、Clob、NClob接口，使用合适的locator类型。应用不直接处理SQl中的locator类型。

对于实现完全物化大对象(LOB),Blob、Clob、NClob对象需要一直保留到free方法调用或LOB被回收。

### 16.3.2 创建Blob、Clob、NClob对象

使用 `createBlob, createClob, createNClob`创建的对象不包含任何数据。数据通过 `setXXX` 设置。

```java
Connection con = DriverManager.getConnection(url, props);
Blob aBlob = con.createBlob();
int numWritten = aBlob.setBytes(1, val);
```

### 16.3.3 在一个ResultSet中查询Blob，Clob，NClob值

这些二进制大对象和字符对象可以被当作更基础的原生内置类型，可以通过 `getBlob, getClob and getNClob`方法查询其值。

```java
Blob blob = rs.getBlob(1);
Clob clob = rs.getClob(2);
```

### 16.3.4 访问Blob，Clob，NClob数据

```java
// 偏移量250，读取100个字节
InputStream is = aBlob.getBinaryStream(250, 100);
BufferedReader br = aClob.getCharacterStream(250, 100);
```

### 16.3.5 存储Blob，Clob，NClob对象

```java
PreparedStatement pstmt = conn.prepareStatement(
    "INSERT INTO bio (image, text) VALUES (?, ?)");
pstmt.setBlob(1, authorImage);
pstmt.setClob(2, authorBio);
```

### 16.3.6 修改Blob，Clob，NClob对象

```java
byte[] val = {0,1,2,3,4};
...
Blob data = rs.getBlob("DATA");
int numWritten = data.setBytes(1, val);
if (dbmd.locatorsUpdateCopy() == true) {
     PreparedStatement ps = conn.prepareStatement(
     "UPDATE datatab SET data = ?");
     ps.setBlob("DATA", data);
     ps.executeUpdate();
}
```

### 16.2.7 释放Blob，Clob，NClob资源

```java
Clob aClob = con.createClob();
int numWritten = aClob.setString(1, val);
aClob.free();
```







    