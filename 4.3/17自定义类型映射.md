# 17.自定义类型映射

本章描述16章的高级类型到Java语言类型的映射，作为JDBC API的一个小扩展。

## 17.1 类型映射

SQL的类型和Java类型有对应的映射，默认映射是：SQL的结构化类型对应Struct接口，SQL的DISTINCT类型
映射到原始类型，UDT（用户自定义类型）映射到Object。

设置一个自定义映射需要2个东西：

1. 写一个SQLData接口的实现，负责转换
2. 放一个元素到java.util.Map里。这个元素必须包含2个东西：
    * SQL UDT的全限定名
    * SQLData实现的Class对象，如果没有实现SQLData会报错


例如，如果UDT的名称为 `mySchemaName.AUTHORS` , SQLData的实现类为 `Authors`, 那这个关联类似下面的代码：

```java
java.util.Map map = conn.getTypeMap();
map.put("mySchemaName.AUTHORS", Class.forName("Authors"));
conn.setTypeMap(map);
```    

在遇到 `ResultSet.getObject, CallableStatement.getObject`方法时，driver负责映射SQL UDT是否有相应的map映射，如果没有则采用默认的。

当带有确定的map参数时，没有映射上也会采用默认的。

## 17.2 类规约

在类型map里的类要满足下面的条件：

* 实现java.sql.SQLData接口
* 提供一个无参构造方法

SQLData接口包含将SQL UDT相互转成Java类的方法，例如，SQLData.readSQL从数据值里流式读取并构建一个Java对象，而SQLData.writeSQL方法
将Java对象写成一个流。

基于流的方式来交换数据类似于Java对象的序列化，SQL的数据流可能会有多种网络协议和数据格式。

## 17.3 SQLData流

这节描述流接口，SQLInput和SQLOutput。

### 17.3.1 查询数据

SQLInput包含了读取数据的方法

```java
SQLInput sqlin;
...
this.str = sqlin.readString();
this.blob = sqlin.readBlob();
this.emp = (Employee)sqlin.readObject();
```

SQLInput还有很多方法，比如 readBytes, readLong.

### 17.3.2 存储数据

调用SQLData.writeSQL时，会创建一个SQLOutput流，通过该对象来写数据

```java
sqlout.writeString(this.str);
sqlout.writeBlob(this.blob);
sqlout.writeObject(this.emp);
```



