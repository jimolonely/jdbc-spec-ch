# 13.Statements

本章描述 Statement接口和子类PreparedStatement，CallableStatement。
同时包括语法转义，性能提示和自动生成键。

## 13.1 Statement接口

Statement接口定义了执行SQL语句的方法，不包含参数构造，PreparedStatement包含参数构造，
CallableStatement添加了从存储过程返回输出参数的方法。

## 13.1.1 创建Statement

创建代码如下所示：

```java
Connection conn = dataSource.getConnection(user, passwd);
Statement stmt = conn.createStatement()
```

每个连接可以创建多个statement

```java
// get a connection from the DataSource object ds
Connection conn = ds.getConnection(user, passwd);
// create two instances of Statement
Statement stmt1 = conn.createStatement();
Statement stmt2 = conn.createStatement();
```

#### 13.1.1.1 设置ResultSet配置

可以通过statement设置resultSet的参数，比如：类型，并发，持有性。例如代码：

```java
Connection conn = ds.getConnection(user, passwd);
Statement stmt = conn.createStatement(
    ResultSet.TYPE_SCROLL_INSENSITIVE,
    ResultSet.CONCUR_UPDATABLE,
    ResultSet.HOLD_CURSORS_OVER_COMMIT);
```

### 13.1.2 执行 Statement对象

执行时要判断语句的类型，如果是SQL查询语句，那么返回一个ResultSet对象，使用 `executeQuery`方法。
如果是一个DDL或DML语句，返回更新的条数，使用 `executeUpdate`. 如果语句类型未知，使用 `execute`方法。

#### 13.1.2.1 返回ResultSet对象

示例代码：

```java
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("select TITLE, AUTHOR, ISBN from BOOKLIST");
while (rs.next()){
    ... 
}
```

如果执行没有返回ResultSet，那么抛出 `SQLException` 异常。

#### 13.1.2.2 返回更新数量

对于DML语句，返回更新的行数或0：

```java
Statement stmt = conn.createStatement();
int rows = stmt.executeUpdate("update STOCK set ORDER = 'Y' where SUPPLY = 0");
if (rows > 0) {
    ...
}
```

如果SQL语句执行返回`ResultSet`, `executeUpdate`方法抛出 `SQLException`

> 注意：如果返回的行数比Integer.MAX_VALUE还大，使用 `executeLargeUpdate`方法

#### 13.1.2.3 返回未知或多个结果

如果有多个结果，或直到运行时才知道类型、返回的行数，那应该用 `execute` 方法。
`getMoreResults, getUpdateCount, getResultSet` 可以用来搜索所有结果。

> 注意：如果返回的行数比Integer.MAX_VALUE还大，使用 `getLargeUpdateCount`方法

如果第一个结果是 `ResultSet`,那么 `execute`方法返回true；如果是一个更新的数量，返回false。

当返回true，那么调用 `getResultSet`来查询结果；返回false，调用 `getUpdateCount`来获取个int。
如果数量大于等于0，表明是更新操作返回的，如果是-1，表示没有更多的结果。

如果有更多结果，可以调用 `getMoreResults`方法来获取下一个结果。

下面是一个例子：

```java
Statement stmt = conn.createStatement();
boolean retval = cstmt.execute(sql_queries);
ResultSet rs;
int count;
do {
    if (retval == false) {
        count = stmt.getUpdateCount();
        if (count == -1) {
            // no more results
            break;
        } else {
            // process update count
        }
    } else { // ResultSet
        rs = stmt.getResultSet();
        // process ResultSet
    } 
    retval = stmt.getMoreResults();
while (true);
```

默认，每次对 `getMoreResults`的调用都会关闭之前由`getResultSet`返回的的ResultSet对象。
但是， `getMoreResults`方法可以接收一个参数指定是否关闭ResultSet，Statement接口定义了3个常量给 `getMoreResults`方法：

* CLOSE_CURRENT_RESULT --- 表明在下一个ResultSet被返回时当前的ResultSet对象应该被关闭
* KEEP_CURRENT_RESULT --- 表明在下一个ResultSet被返回时当前的ResultSet对象应该被保留
* CLOSE_ALL_RESULTS --- 表明在下一个ResultSet被返回时之前所有开放的ResultSet对象都要关闭


如果当前结果是更新数量而不是ResultSet，那么这个参数被忽略。

通过调用 `DatabaseMetaData.supportsMultipleOpenResults`可知道driver是否支持这个功能。

```java
ResultSet rs1 = stmt.getResultSet();
rs1.next();
...
retval = stmt.getMoreResults(Statement.KEEP_CURRENT_RESULT);
if (retval == true) {
    ResultSet rs2 = stmt.getResultSet();
    rs2.next();
    ...
    rs1.next();
}
retval = stmt.getMoreResults(Statement.CLOSE_ALL_RESULTS);
...
```

### 13.1.3 限制Statement对象执行时间

`setQueryTimeout`方法可以被用来指定driver取消执行的最小时间。这个限制对 `execute, executeBatch, executeQuery ,executeUpdate`
都有效。当数据源要终止运行的查询，客户端会收到 `SQLException`异常。

> 注意：某些JDBC driver的实现也可以将超时应用导ResultSet，根据需要来。

> 注意：需要考虑批量执行时超时是对整批语句还是单个语句


### 13.1.4 关闭Statement对象

调用 `Statement.close`关闭。当关闭连接时，statement应该自动关闭。然而，好的编程习惯是用完即关闭。

关闭后会使 ResultSet不合法，所以应该关闭ResultSet以便资源回收。

关闭同样适用于 PreparedStatement 和 CallableStatement.

## 13.2 PreparedStatement接口

PreparedStatement接口继承自Statement接口，增加了设置参数构造的功能。

PreparedStatement对象代表可以被准备的SQL语句，或预编译，用于执行一次或多次。
使用 "?" 代表参数占位，以便输入参数在运行时会变化。

### 13.2.1 创建PreparedStatement对象

```java
Connection conn = ds.getConnection(user, passwd);
PreparedStatement ps = conn.prepareStatement(“INSERT INTO BOOKLIST" +
    "(AUTHOR, TITLE, ISBN) VALUES (?, ?, ?)”);
```

#### 13.2.1.1 设置ResultSet配置

```java
Connection conn = ds.getConnection(user, passwd);
PreparedStatement ps = conn.prepareStatement(
    "SELECT AUTHOR, TITLE FROM BOOKLIST WHERE ISBN = ?",
    ResultSet.TYPE_FORWARD_ONLY,
    ResultSet.CONCUR_UPDATABLE);
```

### 13.2.2 设置参数

PreparedStatement通过 `set<Type>`方法来设置参数值。

每个方法至少2个参数，第一个int代表索引，第二个代表值。

```java
PreparedStatement ps = conn.prepareStatement("INSERT INTO BOOKLIST" +
    "(AUTHOR, TITLE, ISBN) VALUES (?, ?, ?)");
ps.setString(1, "Zamiatin, Evgenii");
ps.setString(2, "We");
ps.setLong(3, 140185852L);
```

可以调用 `clearParameters` 方法来清除已经设置的参数；设置同一个参数多次遵循覆盖原则。

#### 13.2.2.1 类型转换

就是Java数据类型到SQL数据类型（java.sql.Types）的转换，见附录B 表B-2.

#### 13.2.2.2 国际字符集转换

SQL:2003顶一个国际字符的类型，下面的JDBC类型会用来访问国际字符类型：
`NCHAR, NVARCHAR, LONGNVARCHAR, NCLOB`. 这个和 `CHAR, VARCHAR, LONGVARCHAR, CLOB`类型相似。
Java类型使用UTF-16编码，可能将CLOB和NCLOB分开也是有优点的，JDBC规范使用String来代表NCHAR，NVARCHAR，LONGNVARCHAR数据。
JDBC使用NClob代表NCLOB值，在Clob和NClob之间不能自动转换，请参考Java API文档：java.lang.Character查询Java语言如何使用Unicode。

当指定一个参数值是国际字符类型，应用应该调用 `setNString, setNCharacterStream, setNClob,setObject`方法。
如果使用 `setObject`, 目标类型必须被指定为 `Types.NCHAR, Types.NCLOB, Types.NVARCHAR, Types.LONGNVARCHAR`.
如果应用没有明确指定国际字符类型，那么可能解析错误，对 `setXXX`的调用可能抛出 `SQLException`.

如果driver不支持国际字符类型，对上述方法的调用应该抛出 `SQLException`.

查询国际字符时应该调用：`getNString, getNClob, getNCharacterStream, or getObject`.

#### 13.2.2.3 使用setObject方法类型转换

使用setObject方法将一个对象转换成JDBC的类型。

显式的传入一个Object和JDBC类型，driver负责转换，如果不能转，抛出 SQLException异常，如下例子：

```java
Integer value = new Integer(15);
ps.setObject(1, value, java.sql.Types.SHORT);
```

如果隐式的传参，那么默认时object类型：

```java
Integer value = new Integer(15);
// value is mapped to java.sql.Types.INTEGER
ps.setObject(1, value);
```

默认映射见附录B 表B-4.

#### 13.2.2.4 设置NULL参数

带有2个参数，索引和JDBC类型

```java
ps.setNull(2, java.sql.Types.VARCHAR);
```

> 注意：不是所有的数据库都支持null

#### 13.2.2.5 清理参数

通过调用 `clearParameters`清理PreparedStatement参数，包括所有资源。

### 13.2.3

